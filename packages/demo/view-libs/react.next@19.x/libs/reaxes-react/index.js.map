{"version":3,"file":"index.js","mappings":"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","sources":["webpack://mono-reaxes/external module \"react\"","webpack://mono-reaxes/webpack/bootstrap","webpack://mono-reaxes/webpack/runtime/define property getters","webpack://mono-reaxes/webpack/runtime/hasOwnProperty shorthand","webpack://mono-reaxes/external module \"mobx\"","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/utils/assertEnvironment.ts","webpack://mono-reaxes/external module \"react-dom\"","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/utils/observerBatching.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/utils/printDebugValue.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/utils/FinalizationRegistryWrapper.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/utils/reactionCleanupTrackingCommon.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/utils/reactionCleanupTracking.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/utils/createReactionCleanupTrackingUsingFinalizationRegister.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/utils/createTimerBasedReactionCleanupTracking.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/staticRendering.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/useObserver.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/observer.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/parentObserver.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react-lite/index.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react/utils/utils.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react/observerClass.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react/Provider.tsx","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react/disposeOnUnmount.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react/propTypes.ts","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react/index.ts","webpack://mono-reaxes/./packages/reaxes-react/src/enhancer/withHoC.tsx","webpack://mono-reaxes/./packages/reaxes-react/libs/mobx-react/observer.tsx","webpack://mono-reaxes/./packages/reaxes-react/src/enhancer/index.tsx","webpack://mono-reaxes/./packages/reaxes-react/src/reaxper.tsx","webpack://mono-reaxes/./packages/reaxes-react/src/Reaxlass.tsx","webpack://mono-reaxes/external module \"reaxes\""],"sourcesContent":["var x = y => { var x = {}; __webpack_require__.d(x, y); return x; }\nvar y = x => () => x\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_react__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var x = y => { var x = {}; __webpack_require__.d(x, y); return x; }\nvar y = x => () => x\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"$mobx\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__.$mobx, [\"Reaction\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__.Reaction, [\"_allowStateChanges\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__._allowStateChanges, [\"_allowStateReadsEnd\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__._allowStateReadsEnd, [\"_allowStateReadsStart\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__._allowStateReadsStart, [\"configure\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__.configure, [\"createAtom\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__.createAtom, [\"getDependencyTree\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__.getDependencyTree, [\"isObservableArray\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__.isObservableArray, [\"isObservableMap\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__.isObservableMap, [\"isObservableObject\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__.isObservableObject, [\"makeObservable\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__.makeObservable, [\"observable\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__.observable, [\"untracked\"]: () => __WEBPACK_EXTERNAL_MODULE_mobx__.untracked });","import { makeObservable } from \"mobx\"\r\nimport { useState } from \"react\"\r\n\r\nif (!useState) {\r\n    throw new Error(\"mobx-react-lite requires React with Hooks support\")\r\n}\r\nif (!makeObservable) {\r\n    throw new Error(\"mobx-react-lite@3 requires mobx at least version 6 to be available\")\r\n}\r\n","var x = y => { var x = {}; __webpack_require__.d(x, y); return x; }\nvar y = x => () => x\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"unstable_batchedUpdates\"]: () => __WEBPACK_EXTERNAL_MODULE_react_dom_7dac9eee__.unstable_batchedUpdates });","import { configure } from \"mobx\"\r\n\r\nexport function defaultNoopBatch(callback: () => void) {\r\n    callback()\r\n}\r\n\r\nexport function observerBatching(reactionScheduler: any) {\r\n    if (!reactionScheduler) {\r\n        reactionScheduler = defaultNoopBatch\r\n        if (\"production\" !== process.env.NODE_ENV) {\r\n            console.warn(\r\n                \"[MobX] Failed to get unstable_batched updates from react-dom / react-native\"\r\n            )\r\n        }\r\n    }\r\n    configure({ reactionScheduler })\r\n}\r\n\r\nexport const isObserverBatched = () => {\r\n    if (\"production\" !== process.env.NODE_ENV) {\r\n        console.warn(\"[MobX] Deprecated\")\r\n    }\r\n\r\n    return true\r\n}\r\n","import { getDependencyTree, Reaction } from \"mobx\"\r\n\r\nexport function printDebugValue(v: Reaction) {\r\n    return getDependencyTree(v)\r\n}\r\n","declare class FinalizationRegistryType<T> {\r\n    constructor(cleanup: (cleanupToken: T) => void)\r\n    register(object: object, cleanupToken: T, unregisterToken?: object): void\r\n    unregister(unregisterToken: object): void\r\n}\r\n\r\ndeclare const FinalizationRegistry: typeof FinalizationRegistryType | undefined\r\n\r\nconst FinalizationRegistryLocal =\r\n    typeof FinalizationRegistry === \"undefined\" ? undefined : FinalizationRegistry\r\n\r\nexport { FinalizationRegistryLocal as FinalizationRegistry }\r\n","import { Reaction } from \"mobx\"\r\n\r\nexport function createTrackingData(reaction: Reaction) {\r\n    const trackingData: IReactionTracking = {\r\n        reaction,\r\n        mounted: false,\r\n        changedBeforeMount: false,\r\n        cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS\r\n    }\r\n    return trackingData\r\n}\r\n\r\n/**\r\n * Unified api for timers/Finalization registry cleanups\r\n * This abstraction make useObserver much simpler\r\n */\r\nexport interface ReactionCleanupTracking {\r\n    /**\r\n     *\r\n     * @param reaction The reaction to cleanup\r\n     * @param objectRetainedByReact This will be in actual use only when FinalizationRegister is in use\r\n     */\r\n    addReactionToTrack(\r\n        reactionTrackingRef: React.MutableRefObject<IReactionTracking | null>,\r\n        reaction: Reaction,\r\n        objectRetainedByReact: object\r\n    ): IReactionTracking\r\n    recordReactionAsCommitted(reactionRef: React.MutableRefObject<IReactionTracking | null>): void\r\n    forceCleanupTimerToRunNowForTests(): void\r\n    resetCleanupScheduleForTests(): void\r\n}\r\n\r\nexport interface IReactionTracking {\r\n    /** The Reaction created during first render, which may be leaked */\r\n    reaction: Reaction\r\n    /**\r\n     * The time (in ticks) at which point we should dispose of the reaction\r\n     * if this component hasn't yet been fully mounted.\r\n     */\r\n    cleanAt: number\r\n\r\n    /**\r\n     * Whether the component has yet completed mounting (for us, whether\r\n     * its useEffect has run)\r\n     */\r\n    mounted: boolean\r\n\r\n    /**\r\n     * Whether the observables that the component is tracking changed between\r\n     * the first render and the first useEffect.\r\n     */\r\n    changedBeforeMount: boolean\r\n\r\n    /**\r\n     * In case we are using finalization registry based cleanup,\r\n     * this will hold the cleanup token associated with this reaction\r\n     */\r\n    finalizationRegistryCleanupToken?: number\r\n}\r\n\r\n/**\r\n * The minimum time before we'll clean up a Reaction created in a render\r\n * for a component that hasn't managed to run its effects. This needs to\r\n * be big enough to ensure that a component won't turn up and have its\r\n * effects run without being re-rendered.\r\n */\r\nexport const CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10_000\r\n\r\n/**\r\n * The frequency with which we'll check for leaked reactions.\r\n */\r\nexport const CLEANUP_TIMER_LOOP_MILLIS = 10_000\r\n","import { FinalizationRegistry as FinalizationRegistryMaybeUndefined } from \"./FinalizationRegistryWrapper\"\r\nimport { createReactionCleanupTrackingUsingFinalizationRegister } from \"./createReactionCleanupTrackingUsingFinalizationRegister\"\r\nimport { createTimerBasedReactionCleanupTracking } from \"./createTimerBasedReactionCleanupTracking\"\r\nexport type { IReactionTracking } from \"./reactionCleanupTrackingCommon\"\r\n\r\nconst {\r\n    addReactionToTrack,\r\n    recordReactionAsCommitted,\r\n    resetCleanupScheduleForTests,\r\n    forceCleanupTimerToRunNowForTests\r\n} = FinalizationRegistryMaybeUndefined\r\n    ? createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistryMaybeUndefined)\r\n    : createTimerBasedReactionCleanupTracking()\r\n\r\nexport {\r\n    addReactionToTrack,\r\n    recordReactionAsCommitted,\r\n    resetCleanupScheduleForTests,\r\n    forceCleanupTimerToRunNowForTests\r\n}\r\n","import { FinalizationRegistry as FinalizationRegistryMaybeUndefined } from \"./FinalizationRegistryWrapper\"\r\nimport { Reaction } from \"mobx\"\r\nimport {\r\n    ReactionCleanupTracking,\r\n    IReactionTracking,\r\n    createTrackingData\r\n} from \"./reactionCleanupTrackingCommon\"\r\n\r\n/**\r\n * FinalizationRegistry-based uncommitted reaction cleanup\r\n */\r\nexport function createReactionCleanupTrackingUsingFinalizationRegister(\r\n    FinalizationRegistry: NonNullable<typeof FinalizationRegistryMaybeUndefined>\r\n): ReactionCleanupTracking {\r\n    const cleanupTokenToReactionTrackingMap = new Map<number, IReactionTracking>()\r\n    let globalCleanupTokensCounter = 1\r\n\r\n    const registry = new FinalizationRegistry(function cleanupFunction(token: number) {\r\n        const trackedReaction = cleanupTokenToReactionTrackingMap.get(token)\r\n        if (trackedReaction) {\r\n            trackedReaction.reaction.dispose()\r\n            cleanupTokenToReactionTrackingMap.delete(token)\r\n        }\r\n    })\r\n\r\n    return {\r\n        addReactionToTrack(\r\n            reactionTrackingRef: React.MutableRefObject<IReactionTracking | null>,\r\n            reaction: Reaction,\r\n            objectRetainedByReact: object\r\n        ) {\r\n            const token = globalCleanupTokensCounter++\r\n\r\n            registry.register(objectRetainedByReact, token, reactionTrackingRef)\r\n            reactionTrackingRef.current = createTrackingData(reaction)\r\n            reactionTrackingRef.current.finalizationRegistryCleanupToken = token\r\n            cleanupTokenToReactionTrackingMap.set(token, reactionTrackingRef.current)\r\n\r\n            return reactionTrackingRef.current\r\n        },\r\n        recordReactionAsCommitted(reactionRef: React.MutableRefObject<IReactionTracking | null>) {\r\n            registry.unregister(reactionRef)\r\n\r\n            if (reactionRef.current && reactionRef.current.finalizationRegistryCleanupToken) {\r\n                cleanupTokenToReactionTrackingMap.delete(\r\n                    reactionRef.current.finalizationRegistryCleanupToken\r\n                )\r\n            }\r\n        },\r\n        forceCleanupTimerToRunNowForTests() {\r\n            // When FinalizationRegistry in use, this this is no-op\r\n        },\r\n        resetCleanupScheduleForTests() {\r\n            // When FinalizationRegistry in use, this this is no-op\r\n        }\r\n    }\r\n}\r\n","import { Reaction } from \"mobx\"\r\nimport {\r\n    ReactionCleanupTracking,\r\n    IReactionTracking,\r\n    CLEANUP_TIMER_LOOP_MILLIS,\r\n    createTrackingData\r\n} from \"./reactionCleanupTrackingCommon\"\r\n\r\n/**\r\n * timers, gc-style, uncommitted reaction cleanup\r\n */\r\nexport function createTimerBasedReactionCleanupTracking(): ReactionCleanupTracking {\r\n    /**\r\n     * Reactions created by components that have yet to be fully mounted.\r\n     */\r\n    const uncommittedReactionRefs: Set<React.MutableRefObject<IReactionTracking | null>> = new Set()\r\n\r\n    /**\r\n     * Latest 'uncommitted reactions' cleanup timer handle.\r\n     */\r\n    let reactionCleanupHandle: ReturnType<typeof setTimeout> | undefined\r\n\r\n    /* istanbul ignore next */\r\n    /**\r\n     * Only to be used by test functions; do not export outside of mobx-react-lite\r\n     */\r\n    function forceCleanupTimerToRunNowForTests() {\r\n        // This allows us to control the execution of the cleanup timer\r\n        // to force it to run at awkward times in unit tests.\r\n        if (reactionCleanupHandle) {\r\n            clearTimeout(reactionCleanupHandle)\r\n            cleanUncommittedReactions()\r\n        }\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    function resetCleanupScheduleForTests() {\r\n        if (uncommittedReactionRefs.size > 0) {\r\n            for (const ref of uncommittedReactionRefs) {\r\n                const tracking = ref.current\r\n                if (tracking) {\r\n                    tracking.reaction.dispose()\r\n                    ref.current = null\r\n                }\r\n            }\r\n            uncommittedReactionRefs.clear()\r\n        }\r\n\r\n        if (reactionCleanupHandle) {\r\n            clearTimeout(reactionCleanupHandle)\r\n            reactionCleanupHandle = undefined\r\n        }\r\n    }\r\n\r\n    function ensureCleanupTimerRunning() {\r\n        if (reactionCleanupHandle === undefined) {\r\n            reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS)\r\n        }\r\n    }\r\n\r\n    function scheduleCleanupOfReactionIfLeaked(\r\n        ref: React.MutableRefObject<IReactionTracking | null>\r\n    ) {\r\n        uncommittedReactionRefs.add(ref)\r\n\r\n        ensureCleanupTimerRunning()\r\n    }\r\n\r\n    function recordReactionAsCommitted(\r\n        reactionRef: React.MutableRefObject<IReactionTracking | null>\r\n    ) {\r\n        uncommittedReactionRefs.delete(reactionRef)\r\n    }\r\n\r\n    /**\r\n     * Run by the cleanup timer to dispose any outstanding reactions\r\n     */\r\n    function cleanUncommittedReactions() {\r\n        reactionCleanupHandle = undefined\r\n\r\n        // Loop through all the candidate leaked reactions; those older\r\n        // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\r\n\r\n        const now = Date.now()\r\n        uncommittedReactionRefs.forEach(ref => {\r\n            const tracking = ref.current\r\n            if (tracking) {\r\n                if (now >= tracking.cleanAt) {\r\n                    // It's time to tidy up this leaked reaction.\r\n                    tracking.reaction.dispose()\r\n                    ref.current = null\r\n                    uncommittedReactionRefs.delete(ref)\r\n                }\r\n            }\r\n        })\r\n\r\n        if (uncommittedReactionRefs.size > 0) {\r\n            // We've just finished a round of cleanups but there are still\r\n            // some leak candidates outstanding.\r\n            ensureCleanupTimerRunning()\r\n        }\r\n    }\r\n\r\n    return {\r\n        addReactionToTrack(\r\n            reactionTrackingRef: React.MutableRefObject<IReactionTracking | null>,\r\n            reaction: Reaction,\r\n            /**\r\n             * On timer based implementation we don't really need this object,\r\n             * but we keep the same api\r\n             */\r\n            objectRetainedByReact: unknown\r\n        ) {\r\n            reactionTrackingRef.current = createTrackingData(reaction)\r\n            scheduleCleanupOfReactionIfLeaked(reactionTrackingRef)\r\n            return reactionTrackingRef.current\r\n        },\r\n        recordReactionAsCommitted,\r\n        forceCleanupTimerToRunNowForTests,\r\n        resetCleanupScheduleForTests\r\n    }\r\n}\r\n","let globalIsUsingStaticRendering = false\r\n\r\nexport function enableStaticRendering(enable: boolean) {\r\n    globalIsUsingStaticRendering = enable\r\n}\r\n\r\nexport function isUsingStaticRendering(): boolean {\r\n    return globalIsUsingStaticRendering\r\n}\r\n","import { Reaction } from \"mobx\"\r\nimport { printDebugValue } from \"./utils/printDebugValue\"\r\nimport {\r\n    addReactionToTrack,\r\n    IReactionTracking,\r\n    recordReactionAsCommitted\r\n} from \"./utils/reactionCleanupTracking\"\r\nimport { isUsingStaticRendering } from \"./staticRendering\"\r\n\r\nfunction observerComponentNameFor(baseComponentName: string) {\r\n    return `observer${baseComponentName}`\r\n}\r\n\r\n/**\r\n * We use class to make it easier to detect in heap snapshots by name\r\n */\r\nclass ObjectToBeRetainedByReact {}\r\n\r\nfunction objectToBeRetainedByReactFactory() {\r\n    return new ObjectToBeRetainedByReact()\r\n}\r\n\r\nexport function useObserver<T>(fn: () => T, baseComponentName: string = \"observed\"): T {\r\n    if (isUsingStaticRendering()) {\r\n        return fn()\r\n    }\r\n\r\n    const [objectRetainedByReact] = React.useState(objectToBeRetainedByReactFactory)\r\n    // Force update, see #2982\r\n    const [, setState] = React.useState()\r\n    const forceUpdate = () => setState([] as any)\r\n\r\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\r\n    // rendered and abandoned multiple times, so we need to track leaked\r\n    // Reactions.\r\n    const reactionTrackingRef = React.useRef<IReactionTracking | null>(null)\r\n\r\n    if (!reactionTrackingRef.current) {\r\n        // First render for this component (or first time since a previous\r\n        // reaction from an abandoned render was disposed).\r\n\r\n        const newReaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\r\n            // Observable has changed, meaning we want to re-render\r\n            // BUT if we're a component that hasn't yet got to the useEffect()\r\n            // stage, we might be a component that _started_ to render, but\r\n            // got dropped, and we don't want to make state changes then.\r\n            // (It triggers warnings in StrictMode, for a start.)\r\n            if (trackingData.mounted) {\r\n                // We have reached useEffect(), so we're mounted, and can trigger an update\r\n                forceUpdate()\r\n            } else {\r\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\r\n                // when (and if) useEffect() arrives.\r\n                trackingData.changedBeforeMount = true\r\n            }\r\n        })\r\n\r\n        const trackingData = addReactionToTrack(\r\n            reactionTrackingRef,\r\n            newReaction,\r\n            objectRetainedByReact\r\n        )\r\n    }\r\n\r\n    const { reaction } = reactionTrackingRef.current!\r\n    React.useDebugValue(reaction, printDebugValue)\r\n\r\n    React.useEffect(() => {\r\n        // Called on first mount only\r\n        recordReactionAsCommitted(reactionTrackingRef)\r\n\r\n        if (reactionTrackingRef.current) {\r\n            // Great. We've already got our reaction from our render;\r\n            // all we need to do is to record that it's now mounted,\r\n            // to allow future observable changes to trigger re-renders\r\n            reactionTrackingRef.current.mounted = true\r\n            // Got a change before first mount, force an update\r\n            if (reactionTrackingRef.current.changedBeforeMount) {\r\n                reactionTrackingRef.current.changedBeforeMount = false\r\n                forceUpdate()\r\n            }\r\n        } else {\r\n            // The reaction we set up in our render has been disposed.\r\n            // This can be due to bad timings of renderings, e.g. our\r\n            // component was paused for a _very_ long time, and our\r\n            // reaction got cleaned up\r\n\r\n            // Re-create the reaction\r\n            reactionTrackingRef.current = {\r\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), () => {\r\n                    // We've definitely already been mounted at this point\r\n                    forceUpdate()\r\n                }),\r\n                mounted: true,\r\n                changedBeforeMount: false,\r\n                cleanAt: Infinity\r\n            }\r\n            forceUpdate()\r\n        }\r\n\r\n        return () => {\r\n            reactionTrackingRef.current!.reaction.dispose()\r\n            reactionTrackingRef.current = null\r\n        }\r\n    }, [])\r\n\r\n    // render the original component, but have the\r\n    // reaction track the observables, so that rendering\r\n    // can be invalidated (see above) once a dependency changes\r\n    let rendering!: T\r\n    let exception\r\n    reaction.track(() => {\r\n        try {\r\n            rendering = fn()\r\n        } catch (e) {\r\n            exception = e\r\n        }\r\n    })\r\n\r\n    if (exception) {\r\n        throw exception // re-throw any exceptions caught during rendering\r\n    }\r\n\r\n    return rendering\r\n}\r\n","import {\r\n\tforwardRef ,\r\n\tmemo ,\r\n} from \"react\";\r\n\r\nimport { isUsingStaticRendering } from \"./staticRendering\";\r\nimport { useObserver } from \"./useObserver\";\r\n\r\nlet warnObserverOptionsDeprecated = true;\r\n\r\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for;\r\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\r\nconst ReactForwardRefSymbol = hasSymbol\r\n\t? Symbol.for( \"react.forward_ref\" )\r\n\t: typeof forwardRef === \"function\" && forwardRef( ( props : any ) => null )[ \"$$typeof\" ];\r\n\r\nconst ReactMemoSymbol = hasSymbol\r\n\t? Symbol.for( \"react.memo\" )\r\n\t: typeof memo === \"function\" && memo( ( props : any ) => null )[ \"$$typeof\" ];\r\n\r\nexport interface IObserverOptions {\r\n\treadonly forwardRef? : boolean;\r\n}\r\n\r\nexport function observer<P extends object , TRef = {}>(\r\n\tbaseComponent : React.ForwardRefRenderFunction<TRef , P> ,\r\n\toptions : IObserverOptions & { forwardRef : true } ,\r\n) : React.MemoExoticComponent<React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>>\r\n\r\nexport function observer<P extends object , TRef = {}>(\r\n\tbaseComponent : React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>> ,\r\n) : React.MemoExoticComponent<React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>>\r\n\r\nexport function observer<P extends object>(\r\n\tbaseComponent : React.FunctionComponent<P> ,\r\n\toptions? : IObserverOptions ,\r\n) : React.FunctionComponent<P>\r\n\r\nexport function observer<C extends React.FunctionComponent<any> | React.ForwardRefRenderFunction<any> ,\r\n\tOptions extends IObserverOptions>(\r\n\tbaseComponent : C ,\r\n\toptions? : Options ,\r\n) : Options extends { forwardRef : true }\r\n\t? C extends React.ForwardRefRenderFunction<infer TRef , infer P>\r\n\t\t? C &\r\n\t\tReact.MemoExoticComponent<React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>>\r\n\t\t: never /* forwardRef set for a non forwarding component */\r\n\t: C & { displayName : string }\r\n\r\n// n.b. base case is not used for actual typings or exported in the typing files\r\nexport function observer<P extends object , TRef = {}>(\r\n\tbaseComponent :\r\n\t\t| React.ForwardRefRenderFunction<TRef , P>\r\n\t\t| React.FunctionComponent<P>\r\n\t\t| React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>> ,\r\n\t// TODO remove in next major\r\n\toptions? : IObserverOptions ,\r\n) {\t\r\n\tif ( process.env.NODE_ENV !== \"production\" && warnObserverOptionsDeprecated && options ) {\r\n\t\twarnObserverOptionsDeprecated = false;\r\n\t\tconsole.warn(\r\n\t\t\t`[mobx-react-lite] \\`observer(fn, { forwardRef: true })\\` is deprecated, use \\`observer(React.forwardRef(fn))\\`` ,\r\n\t\t);\r\n\t}\r\n\t\r\n\tif ( ReactMemoSymbol && baseComponent[ \"$$typeof\" ] === ReactMemoSymbol ) {\r\n\t\tthrow new Error(\r\n\t\t\t`[mobx-react-lite] You are trying to use \\`observer\\` on a function component wrapped in either another \\`observer\\` or \\`React.memo\\`. The observer already applies 'React.memo' for you.` ,\r\n\t\t);\r\n\t}\r\n\t\r\n\t// The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\r\n\tif ( isUsingStaticRendering() ) {\r\n\t\treturn baseComponent;\r\n\t}\r\n\t\r\n\tlet useForwardRef = options?.forwardRef ?? false;\r\n\tlet render = baseComponent;\r\n\t\r\n\tconst baseComponentName = baseComponent.displayName || baseComponent.name;\r\n\t\r\n\t// If already wrapped with forwardRef, unwrap,\r\n\t// so we can patch render and apply memo\r\n\tif ( ReactForwardRefSymbol && baseComponent[ \"$$typeof\" ] === ReactForwardRefSymbol ) {\r\n\t\tuseForwardRef = true;\r\n\t\trender = baseComponent[ \"render\" ];\r\n\t\tif ( typeof render !== \"function\" ) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`[mobx-react-lite] \\`render\\` property of ForwardRef was not a function` ,\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\t\r\n\tlet observerComponent = ( props : any , ref : React.Ref<TRef> ) => {\r\n\t\treturn useObserver( () => render( props , ref ) , baseComponentName );\r\n\t};\r\n\t\r\n\t// Don't set `displayName` for anonymous components,\r\n\t// so the `displayName` can be customized by user, see #3192.\r\n\tif ( baseComponentName !== \"\" ) {\r\n\t\t;(\r\n\t\t\tobserverComponent as React.FunctionComponent\r\n\t\t).displayName = baseComponentName;\r\n\t}\r\n\t\r\n\t// Support legacy context: `contextTypes` must be applied before `memo`\r\n\tif ( (\r\n\t\tbaseComponent as any\r\n\t).contextTypes ) {\r\n\t\t;(\r\n\t\t\tobserverComponent as React.FunctionComponent\r\n\t\t).contextTypes = (\r\n\t\t\tbaseComponent as any\r\n\t\t).contextTypes;\r\n\t}\r\n\t\r\n\tif ( useForwardRef ) {\r\n\t\t// `forwardRef` must be applied prior `memo`\r\n\t\t// `forwardRef(observer(cmp))` throws:\r\n\t\t// \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\r\n\t\tobserverComponent = forwardRef( observerComponent );\r\n\t}\r\n\t\r\n\t// memo; we are not interested in deep updates\r\n\t// in props; we assume that if deep objects are changed,\r\n\t// this is in observables, which would have been tracked anyway\r\n\tobserverComponent = memo( observerComponent );\r\n\t\r\n\tcopyStaticProperties( baseComponent , observerComponent );\r\n\t\r\n\tif ( \"production\" !== process.env.NODE_ENV ) {\r\n\t\tObject.defineProperty( observerComponent , \"contextTypes\" , {\r\n\t\t\tset() {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`[mobx-react-lite] \\`${\r\n\t\t\t\t\t\tthis.displayName || this.type?.displayName || \"Component\"\r\n\t\t\t\t\t}.contextTypes\\` must be set before applying \\`observer\\`.` ,\r\n\t\t\t\t);\r\n\t\t\t} ,\r\n\t\t} );\r\n\t}\r\n\t\r\n\treturn observerComponent;\r\n}\r\n\r\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\r\nconst hoistBlackList : any = {\r\n\t$$typeof : true ,\r\n\trender : true ,\r\n\tcompare : true ,\r\n\ttype : true ,\r\n\t// Don't redefine `displayName`,\r\n\t// it's defined as getter-setter pair on `memo` (see #3192).\r\n\tdisplayName : true ,\r\n};\r\n\r\nfunction copyStaticProperties( base : any , target : any ) {\r\n\tObject.keys( base ).\r\n\tforEach( key => {\r\n\t\tif ( !hoistBlackList[ key ] ) {\r\n\t\t\tObject.defineProperty( target , key , Object.getOwnPropertyDescriptor( base , key )! );\r\n\t\t}\r\n\t} );\r\n}\r\n","import { Reaction } from \"mobx\";\r\nimport {\r\n\tforwardRef ,\r\n\tmemo ,\r\n} from \"react\";\r\nimport { printDebugValue } from \"./utils/printDebugValue\";\r\nimport {\r\n\taddReactionToTrack ,\r\n\tIReactionTracking ,\r\n\trecordReactionAsCommitted ,\r\n} from \"./utils/reactionCleanupTracking\";\r\nimport { isUsingStaticRendering } from \"./staticRendering\";\r\n\r\n\r\nfunction observerComponentNameFor( baseComponentName : string ) {\r\n\treturn `observer${ baseComponentName }`;\r\n}\r\n\r\n/**\r\n * We use class to make it easier to detect in heap snapshots by name\r\n */\r\nclass ObjectToBeRetainedByReact {\r\n}\r\n\r\nfunction objectToBeRetainedByReactFactory() {\r\n\treturn new ObjectToBeRetainedByReact();\r\n}\r\n\r\nexport function useObserver<T>( fn : () => T , baseComponentName : string = \"observed\" ,instance) : T {\r\n\tif ( isUsingStaticRendering() ) {\r\n\t\treturn fn();\r\n\t}\r\n\t// console.log( instance );\r\n\tconst [ objectRetainedByReact ] = React.useState( objectToBeRetainedByReactFactory );\r\n\t// Force update, see #2982\r\n\tconst [ , setState ] = React.useState();\r\n\tconst parentForceUpdate = () => instance.forceUpdate();\r\n\tconst forceUpdate = () => setState([] as any);\r\n\t// StrictMode/ConcurrentMode/Suspense may mean that our component is\r\n\t// rendered and abandoned multiple times, so we need to track leaked\r\n\t// Reactions.\r\n\tconst reactionTrackingRef = React.useRef<IReactionTracking | null>( null );\r\n\t\r\n\tif ( !reactionTrackingRef.current ) {\r\n\t\t// First render for this component (or first time since a previous\r\n\t\t// reaction from an abandoned render was disposed).\r\n\t\t\r\n\t\tconst newReaction = new Reaction( observerComponentNameFor( baseComponentName ) , () => {\r\n\t\t\t// Observable has changed, meaning we want to re-render\r\n\t\t\t// BUT if we're a component that hasn't yet got to the useEffect()\r\n\t\t\t// stage, we might be a component that _started_ to render, but\r\n\t\t\t// got dropped, and we don't want to make state changes then.\r\n\t\t\t// (It triggers warnings in StrictMode, for a start.)\r\n\t\t\tif ( trackingData.mounted ) {\r\n\t\t\t\t// We have reached useEffect(), so we're mounted, and can trigger an update\r\n\t\t\t\tparentForceUpdate();\r\n\t\t\t\tforceUpdate();\r\n\t\t\t} else {\r\n\t\t\t\t// We haven't yet reached useEffect(), so we'll need to trigger a re-render\r\n\t\t\t\t// when (and if) useEffect() arrives.\r\n\t\t\t\ttrackingData.changedBeforeMount = true;\r\n\t\t\t}\r\n\t\t} );\r\n\t\t\r\n\t\tconst trackingData = addReactionToTrack(\r\n\t\t\treactionTrackingRef ,\r\n\t\t\tnewReaction ,\r\n\t\t\tobjectRetainedByReact ,\r\n\t\t);\r\n\t}\r\n\t\r\n\tconst { reaction } = reactionTrackingRef.current!;\r\n\tReact.useDebugValue( reaction , printDebugValue );\r\n\t\r\n\tReact.useEffect( () => {\r\n\t\t// Called on first mount only\r\n\t\trecordReactionAsCommitted( reactionTrackingRef );\r\n\t\t\r\n\t\tif ( reactionTrackingRef.current ) {\r\n\t\t\t// Great. We've already got our reaction from our render;\r\n\t\t\t// all we need to do is to record that it's now mounted,\r\n\t\t\t// to allow future observable changes to trigger re-renders\r\n\t\t\treactionTrackingRef.current.mounted = true;\r\n\t\t\t// Got a change before first mount, force an update\r\n\t\t\tif ( reactionTrackingRef.current.changedBeforeMount ) {\r\n\t\t\t\treactionTrackingRef.current.changedBeforeMount = false;\r\n\t\t\t\tparentForceUpdate();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// The reaction we set up in our render has been disposed.\r\n\t\t\t// This can be due to bad timings of renderings, e.g. our\r\n\t\t\t// component was paused for a _very_ long time, and our\r\n\t\t\t// reaction got cleaned up\r\n\t\t\t\r\n\t\t\t// Re-create the reaction\r\n\t\t\treactionTrackingRef.current = {\r\n\t\t\t\treaction : new Reaction( observerComponentNameFor( baseComponentName ) , () => {\r\n\t\t\t\t\t// We've definitely already been mounted at this point\r\n\t\t\t\t\tparentForceUpdate();\r\n\t\t\t\t} ) ,\r\n\t\t\t\tmounted : true ,\r\n\t\t\t\tchangedBeforeMount : false ,\r\n\t\t\t\tcleanAt : Infinity ,\r\n\t\t\t};\r\n\t\t\tparentForceUpdate();\r\n\t\t}\r\n\t\t\r\n\t\treturn () => {\r\n\t\t\treactionTrackingRef.current!.reaction.dispose();\r\n\t\t\treactionTrackingRef.current = null;\r\n\t\t};\r\n\t} , [] );\r\n\t\r\n\t// render the original component, but have the\r\n\t// reaction track the observables, so that rendering\r\n\t// can be invalidated (see above) once a dependency changes\r\n\tlet rendering! : T;\r\n\tlet exception;\r\n\treaction.track( () => {\r\n\t\ttry {\r\n\t\t\trendering = fn();\r\n\t\t} catch ( e ) {\r\n\t\t\texception = e;\r\n\t\t}\r\n\t} );\r\n\t\r\n\tif ( exception ) {\r\n\t\tthrow exception; // re-throw any exceptions caught during rendering\r\n\t}\r\n\t\r\n\treturn rendering;\r\n}\r\n\r\n\r\nlet warnObserverOptionsDeprecated = true;\r\n\r\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for;\r\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\r\nconst ReactForwardRefSymbol = hasSymbol\r\n\t? Symbol.for( \"react.forward_ref\" )\r\n\t: typeof forwardRef === \"function\" && forwardRef( ( props : any ) => null )[ \"$$typeof\" ];\r\n\r\nconst ReactMemoSymbol = hasSymbol\r\n\t? Symbol.for( \"react.memo\" )\r\n\t: typeof memo === \"function\" && memo( ( props : any ) => null )[ \"$$typeof\" ];\r\n\r\nexport interface IObserverOptions {\r\n\treadonly forwardRef? : boolean;\r\n}\r\n\r\n\r\n// n.b. base case is not used for actual typings or exported in the typing files\r\nexport function parentObserver<P extends object , TRef = {}>(\r\n\tbaseComponent :\r\n\t\t| React.ForwardRefRenderFunction<TRef , P>\r\n\t\t| React.FunctionComponent<P>\r\n\t\t| React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>> ,\r\n\t// TODO remove in next major\r\n\toptions? : IObserverOptions ,\r\n) {\r\n\tif ( process.env.NODE_ENV !== \"production\" && warnObserverOptionsDeprecated && options ) {\r\n\t\twarnObserverOptionsDeprecated = false;\r\n\t\tconsole.warn(\r\n\t\t\t`[mobx-react-lite] \\`observer(fn, { forwardRef: true })\\` is deprecated, use \\`observer(React.forwardRef(fn))\\`` ,\r\n\t\t);\r\n\t}\r\n\t\r\n\tif ( ReactMemoSymbol && baseComponent[ \"$$typeof\" ] === ReactMemoSymbol ) {\r\n\t\tthrow new Error(\r\n\t\t\t`[mobx-react-lite] You are trying to use \\`observer\\` on a function component wrapped in either another \\`observer\\` or \\`React.memo\\`. The observer already applies 'React.memo' for you.` ,\r\n\t\t);\r\n\t}\r\n\t\r\n\t// The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\r\n\tif ( isUsingStaticRendering() ) {\r\n\t\treturn baseComponent;\r\n\t}\r\n\t\r\n\tlet useForwardRef = options?.forwardRef ?? false;\r\n\tlet render = baseComponent;\r\n\t\r\n\tconst baseComponentName = baseComponent.displayName || baseComponent.name;\r\n\t\r\n\t// If already wrapped with forwardRef, unwrap,\r\n\t// so we can patch render and apply memo\r\n\tif ( ReactForwardRefSymbol && baseComponent[ \"$$typeof\" ] === ReactForwardRefSymbol ) {\r\n\t\tuseForwardRef = true;\r\n\t\trender = baseComponent[ \"render\" ];\r\n\t\tif ( typeof render !== \"function\" ) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`[mobx-react-lite] \\`render\\` property of ForwardRef was not a function` ,\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\tlet observerComponent = ( props : any , ref : React.Ref<TRef> ) => {\r\n\t\treturn useObserver( () => render( props , ref ) , baseComponentName ,props.instance);\r\n\t};\r\n\t\r\n\t// Don't set `displayName` for anonymous components,\r\n\t// so the `displayName` can be customized by user, see #3192.\r\n\tif ( baseComponentName !== \"\" ) {\r\n\t\t;(\r\n\t\t\tobserverComponent as React.FunctionComponent\r\n\t\t).displayName = baseComponentName;\r\n\t}\r\n\t\r\n\t// Support legacy context: `contextTypes` must be applied before `memo`\r\n\tif ( (\r\n\t\tbaseComponent as any\r\n\t).contextTypes ) {\r\n\t\t;(\r\n\t\t\tobserverComponent as React.FunctionComponent\r\n\t\t).contextTypes = (\r\n\t\t\tbaseComponent as any\r\n\t\t).contextTypes;\r\n\t}\r\n\t\r\n\tif ( useForwardRef ) {\r\n\t\t// `forwardRef` must be applied prior `memo`\r\n\t\t// `forwardRef(observer(cmp))` throws:\r\n\t\t// \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\r\n\t\tobserverComponent = forwardRef( observerComponent );\r\n\t}\r\n\t\r\n\t// memo; we are not interested in deep updates\r\n\t// in props; we assume that if deep objects are changed,\r\n\t// this is in observables, which would have been tracked anyway\r\n\tobserverComponent = ( observerComponent );\r\n\t\r\n\tcopyStaticProperties( baseComponent , observerComponent );\r\n\t\r\n\tif ( \"production\" !== process.env.NODE_ENV ) {\r\n\t\tObject.defineProperty( observerComponent , \"contextTypes\" , {\r\n\t\t\tset() {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`[mobx-react-lite] \\`${\r\n\t\t\t\t\t\tthis.displayName || this.type?.displayName || \"Component\"\r\n\t\t\t\t\t}.contextTypes\\` must be set before applying \\`observer\\`.` ,\r\n\t\t\t\t);\r\n\t\t\t} ,\r\n\t\t} );\r\n\t}\r\n\t\r\n\treturn observerComponent;\r\n}\r\n\r\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\r\nconst hoistBlackList : any = {\r\n\t$$typeof : true ,\r\n\trender : true ,\r\n\tcompare : true ,\r\n\ttype : true ,\r\n\t// Don't redefine `displayName`,\r\n\t// it's defined as getter-setter pair on `memo` (see #3192).\r\n\tdisplayName : true ,\r\n};\r\n\r\nfunction copyStaticProperties( base : any , target : any ) {\r\n\tObject.keys( base ).\r\n\tforEach( key => {\r\n\t\tif ( !hoistBlackList[ key ] ) {\r\n\t\t\tObject.defineProperty( target , key , Object.getOwnPropertyDescriptor( base , key )! );\r\n\t\t}\r\n\t} );\r\n}\r\n","import \"./utils/assertEnvironment\"\r\n\r\nimport { unstable_batchedUpdates as batch } from \"./utils/reactBatchedUpdates\"\r\nimport { observerBatching } from \"./utils/observerBatching\"\r\nimport { useDeprecated } from \"./utils/utils\"\r\nimport { useObserver as useObserverOriginal } from \"./useObserver\"\r\nimport { enableStaticRendering } from \"./staticRendering\"\r\n\r\nobserverBatching(batch)\r\n\r\nexport { isUsingStaticRendering, enableStaticRendering } from \"./staticRendering\"\r\nexport { observer } from \"./observer\"\r\nexport type { IObserverOptions } from \"./observer\"\r\nexport { Observer } from \"./ObserverComponent\"\r\nexport { parentObserver } from \"./parentObserver\";\r\nexport { useLocalObservable } from \"./useLocalObservable\"\r\nexport { useLocalStore } from \"./useLocalStore\"\r\nexport { useAsObservableSource } from \"./useAsObservableSource\"\r\nexport { resetCleanupScheduleForTests as clearTimers } from \"./utils/reactionCleanupTracking\"\r\n\r\nexport function useObserver<T>(fn: () => T, baseComponentName: string = \"observed\"): T {\r\n    if (\"production\" !== process.env.NODE_ENV) {\r\n        useDeprecated(\r\n            \"[mobx-react-lite] 'useObserver(fn)' is deprecated. Use `<Observer>{fn}</Observer>` instead, or wrap the entire component in `observer`.\"\r\n        )\r\n    }\r\n    return useObserverOriginal(fn, baseComponentName)\r\n}\r\n\r\nexport { isObserverBatched, observerBatching } from \"./utils/observerBatching\"\r\n\r\nexport function useStaticRendering(enable: boolean) {\r\n    if (\"production\" !== process.env.NODE_ENV) {\r\n        console.warn(\r\n            \"[mobx-react-lite] 'useStaticRendering' is deprecated, use 'enableStaticRendering' instead\"\r\n        )\r\n    }\r\n    enableStaticRendering(enable)\r\n}\r\n","let symbolId = 0\r\nfunction createSymbol(name: string): symbol | string {\r\n    if (typeof Symbol === \"function\") {\r\n        return Symbol(name)\r\n    }\r\n    const symbol = `__$mobx-react ${name} (${symbolId})`\r\n    symbolId++\r\n    return symbol\r\n}\r\n\r\nconst createdSymbols = {}\r\nexport function newSymbol(name: string): symbol | string {\r\n    if (!createdSymbols[name]) {\r\n        createdSymbols[name] = createSymbol(name)\r\n    }\r\n    return createdSymbols[name]\r\n}\r\n\r\nexport function shallowEqual(objA: any, objB: any): boolean {\r\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\r\n    if (is(objA, objB)) {\r\n        return true\r\n    }\r\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\r\n        return false\r\n    }\r\n    const keysA = Object.keys(objA)\r\n    const keysB = Object.keys(objB)\r\n    if (keysA.length !== keysB.length) {\r\n        return false\r\n    }\r\n    for (let i = 0; i < keysA.length; i++) {\r\n        if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\r\n            return false\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\nfunction is(x: any, y: any): boolean {\r\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\r\n    if (x === y) {\r\n        return x !== 0 || 1 / x === 1 / y\r\n    } else {\r\n        return x !== x && y !== y\r\n    }\r\n}\r\n\r\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\r\nconst hoistBlackList = {\r\n    $$typeof: 1,\r\n    render: 1,\r\n    compare: 1,\r\n    type: 1,\r\n    childContextTypes: 1,\r\n    contextType: 1,\r\n    contextTypes: 1,\r\n    defaultProps: 1,\r\n    getDefaultProps: 1,\r\n    getDerivedStateFromError: 1,\r\n    getDerivedStateFromProps: 1,\r\n    mixins: 1,\r\n    displayName: 1,\r\n    propTypes: 1\r\n}\r\n\r\nexport function copyStaticProperties(base: object, target: object): void {\r\n    const protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base))\r\n    Object.getOwnPropertyNames(base).forEach(key => {\r\n        if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\r\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\r\n * @param target\r\n * @param prop\r\n * @param value\r\n */\r\nexport function setHiddenProp(target: object, prop: any, value: any): void {\r\n    if (!Object.hasOwnProperty.call(target, prop)) {\r\n        Object.defineProperty(target, prop, {\r\n            enumerable: false,\r\n            configurable: true,\r\n            writable: true,\r\n            value\r\n        })\r\n    } else {\r\n        target[prop] = value\r\n    }\r\n}\r\n\r\n/**\r\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\r\n * and the handler provided by mobx-react\r\n */\r\nconst mobxMixins = newSymbol(\"patchMixins\")\r\nconst mobxPatchedDefinition = newSymbol(\"patchedDefinition\")\r\n\r\nexport interface Mixins extends Record<string, any> {\r\n    locks: number\r\n    methods: Array<Function>\r\n}\r\n\r\nfunction getMixins(target: object, methodName: string): Mixins {\r\n    const mixins = (target[mobxMixins] = target[mobxMixins] || {})\r\n    const methodMixins = (mixins[methodName] = mixins[methodName] || {})\r\n    methodMixins.locks = methodMixins.locks || 0\r\n    methodMixins.methods = methodMixins.methods || []\r\n    return methodMixins\r\n}\r\n\r\nfunction wrapper(realMethod: Function, mixins: Mixins, ...args: Array<any>) {\r\n    // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\r\n    mixins.locks++\r\n\r\n    try {\r\n        let retVal\r\n        if (realMethod !== undefined && realMethod !== null) {\r\n            retVal = realMethod.apply(this, args)\r\n        }\r\n\r\n        return retVal\r\n    } finally {\r\n        mixins.locks--\r\n        if (mixins.locks === 0) {\r\n            mixins.methods.forEach(mx => {\r\n                mx.apply(this, args)\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nfunction wrapFunction(realMethod: Function, mixins: Mixins): (...args: Array<any>) => any {\r\n    const fn = function (...args: Array<any>) {\r\n        wrapper.call(this, realMethod, mixins, ...args)\r\n    }\r\n    return fn\r\n}\r\n\r\nexport function patch(target: object, methodName: string, mixinMethod: Function): void {\r\n    const mixins = getMixins(target, methodName)\r\n\r\n    if (mixins.methods.indexOf(mixinMethod) < 0) {\r\n        mixins.methods.push(mixinMethod)\r\n    }\r\n\r\n    const oldDefinition = Object.getOwnPropertyDescriptor(target, methodName)\r\n    if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\r\n        // already patched definition, do not repatch\r\n        return\r\n    }\r\n\r\n    const originalMethod = target[methodName]\r\n    const newDefinition = createDefinition(\r\n        target,\r\n        methodName,\r\n        oldDefinition ? oldDefinition.enumerable : undefined,\r\n        mixins,\r\n        originalMethod\r\n    )\r\n\r\n    Object.defineProperty(target, methodName, newDefinition)\r\n}\r\n\r\nfunction createDefinition(\r\n    target: object,\r\n    methodName: string,\r\n    enumerable: any,\r\n    mixins: Mixins,\r\n    originalMethod: Function\r\n): PropertyDescriptor {\r\n    let wrappedFunc = wrapFunction(originalMethod, mixins)\r\n\r\n    return {\r\n        [mobxPatchedDefinition]: true,\r\n        get: function () {\r\n            return wrappedFunc\r\n        },\r\n        set: function (value) {\r\n            if (this === target) {\r\n                wrappedFunc = wrapFunction(value, mixins)\r\n            } else {\r\n                // when it is an instance of the prototype/a child prototype patch that particular case again separately\r\n                // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\r\n                // e.g. the method for super might not be the same as the method for the prototype which might be not the same\r\n                // as the method for the instance\r\n                const newDefinition = createDefinition(this, methodName, enumerable, mixins, value)\r\n                Object.defineProperty(this, methodName, newDefinition)\r\n            }\r\n        },\r\n        configurable: true,\r\n        enumerable: enumerable\r\n    }\r\n}\r\n","import { PureComponent, Component } from \"react\"\r\nimport {\r\n    createAtom,\r\n    _allowStateChanges,\r\n    Reaction,\r\n    $mobx,\r\n    _allowStateReadsStart,\r\n    _allowStateReadsEnd\r\n} from \"mobx\"\r\nimport { isUsingStaticRendering } from \"reaxes-react/libs/mobx-react-lite\"\r\n\r\nimport { newSymbol, shallowEqual, setHiddenProp, patch } from \"./utils/utils\"\r\n\r\nconst mobxAdminProperty = $mobx || \"$mobx\"\r\nconst mobxObserverProperty = newSymbol(\"isMobXReactObserver\")\r\nconst mobxIsUnmounted = newSymbol(\"isUnmounted\")\r\nconst skipRenderKey = newSymbol(\"skipRender\")\r\nconst isForcingUpdateKey = newSymbol(\"isForcingUpdate\")\r\n\r\nexport function makeClassComponentObserver(\r\n    componentClass: React.ComponentClass<any, any>\r\n): React.ComponentClass<any, any> {\r\n    const target = componentClass.prototype\r\n\r\n    if (componentClass[mobxObserverProperty]) {\r\n        const displayName = getDisplayName(target)\r\n        console.warn(\r\n            `The provided component class (${displayName})\r\n                has already been declared as an observer component.`\r\n        )\r\n    } else {\r\n        componentClass[mobxObserverProperty] = true\r\n    }\r\n\r\n    if (target.componentWillReact)\r\n        throw new Error(\"The componentWillReact life-cycle event is no longer supported\")\r\n    if (componentClass[\"__proto__\"] !== PureComponent) {\r\n        if (!target.shouldComponentUpdate) target.shouldComponentUpdate = observerSCU\r\n        else if (target.shouldComponentUpdate !== observerSCU)\r\n            // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\r\n            throw new Error(\r\n                \"It is not allowed to use shouldComponentUpdate in observer based components.\"\r\n            )\r\n    }\r\n\r\n    // this.props and this.state are made observable, just to make sure @computed fields that\r\n    // are defined inside the component, and which rely on state or props, re-compute if state or props change\r\n    // (otherwise the computed wouldn't update and become stale on props change, since props are not observable)\r\n    // However, this solution is not without it's own problems: https://github.com/mobxjs/mobx-react/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aobservable-props-or-not+\r\n    makeObservableProp(target, \"props\")\r\n    makeObservableProp(target, \"state\")\r\n    if (componentClass.contextType) {\r\n        makeObservableProp(target, \"context\")\r\n    }\r\n\r\n    const baseRender = target.render\r\n    if (typeof baseRender !== \"function\") {\r\n        const displayName = getDisplayName(target)\r\n        throw new Error(\r\n            `[mobx-react] class component (${displayName}) is missing \\`render\\` method.` +\r\n                `\\n\\`observer\\` requires \\`render\\` being a function defined on prototype.` +\r\n                `\\n\\`render = () => {}\\` or \\`render = function() {}\\` is not supported.`\r\n        )\r\n    }\r\n    target.render = function () {\r\n        return makeComponentReactive.call(this, baseRender)\r\n    }\r\n    patch(target, \"componentWillUnmount\", function () {\r\n        if (isUsingStaticRendering() === true) return\r\n        this.render[mobxAdminProperty]?.dispose()\r\n        this[mobxIsUnmounted] = true\r\n\r\n        if (!this.render[mobxAdminProperty]) {\r\n            // Render may have been hot-swapped and/or overriden by a subclass.\r\n            const displayName = getDisplayName(this)\r\n            console.warn(\r\n                `The reactive render of an observer class component (${displayName})\r\n                was overriden after MobX attached. This may result in a memory leak if the\r\n                overriden reactive render was not properly disposed.`\r\n            )\r\n        }\r\n    })\r\n    return componentClass\r\n}\r\n\r\n// Generates a friendly name for debugging\r\nfunction getDisplayName(comp: any) {\r\n    return (\r\n        comp.displayName ||\r\n        comp.name ||\r\n        (comp.constructor && (comp.constructor.displayName || comp.constructor.name)) ||\r\n        \"<component>\"\r\n    )\r\n}\r\n\r\nfunction makeComponentReactive(render: any) {\r\n    if (isUsingStaticRendering() === true) return render.call(this)\r\n\r\n    /**\r\n     * If props are shallowly modified, react will render anyway,\r\n     * so atom.reportChanged() should not result in yet another re-render\r\n     */\r\n    setHiddenProp(this, skipRenderKey, false)\r\n    /**\r\n     * forceUpdate will re-assign this.props. We don't want that to cause a loop,\r\n     * so detect these changes\r\n     */\r\n    setHiddenProp(this, isForcingUpdateKey, false)\r\n\r\n    const initialName = getDisplayName(this)\r\n    const baseRender = render.bind(this)\r\n\r\n    let isRenderingPending = false\r\n\r\n    const reaction = new Reaction(`${initialName}.render()`, () => {\r\n        if (!isRenderingPending) {\r\n            // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\r\n            // This unidiomatic React usage but React will correctly warn about this so we continue as usual\r\n            // See #85 / Pull #44\r\n            isRenderingPending = true\r\n            if (this[mobxIsUnmounted] !== true) {\r\n                let hasError = true\r\n                try {\r\n                    setHiddenProp(this, isForcingUpdateKey, true)\r\n                    if (!this[skipRenderKey]) Component.prototype.forceUpdate.call(this)\r\n                    hasError = false\r\n                } finally {\r\n                    setHiddenProp(this, isForcingUpdateKey, false)\r\n                    if (hasError) reaction.dispose()\r\n                }\r\n            }\r\n        }\r\n    })\r\n\r\n    reaction[\"reactComponent\"] = this\r\n    reactiveRender[mobxAdminProperty] = reaction\r\n    this.render = reactiveRender\r\n\r\n    function reactiveRender() {\r\n        isRenderingPending = false\r\n        let exception: unknown = undefined\r\n        let rendering = undefined\r\n        reaction.track(() => {\r\n            try {\r\n                rendering = _allowStateChanges(false, baseRender)\r\n            } catch (e) {\r\n                exception = e\r\n            }\r\n        })\r\n        if (exception) {\r\n            throw exception\r\n        }\r\n        return rendering\r\n    }\r\n\r\n    return reactiveRender.call(this)\r\n}\r\n\r\nfunction observerSCU(nextProps: React.ClassAttributes<any>, nextState: any): boolean {\r\n    if (isUsingStaticRendering()) {\r\n        console.warn(\r\n            \"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\"\r\n        )\r\n    }\r\n    // update on any state changes (as is the default)\r\n    if (this.state !== nextState) {\r\n        return true\r\n    }\r\n    // update if props are shallowly not equal, inspired by PureRenderMixin\r\n    // we could return just 'false' here, and avoid the `skipRender` checks etc\r\n    // however, it is nicer if lifecycle events are triggered like usually,\r\n    // so we return true here if props are shallowly modified.\r\n    return !shallowEqual(this.props, nextProps)\r\n}\r\n\r\nfunction makeObservableProp(target: any, propName: string): void {\r\n    const valueHolderKey = newSymbol(`reactProp_${propName}_valueHolder`)\r\n    const atomHolderKey = newSymbol(`reactProp_${propName}_atomHolder`)\r\n    function getAtom() {\r\n        if (!this[atomHolderKey]) {\r\n            setHiddenProp(this, atomHolderKey, createAtom(\"reactive \" + propName))\r\n        }\r\n        return this[atomHolderKey]\r\n    }\r\n    Object.defineProperty(target, propName, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get: function () {\r\n            let prevReadState = false\r\n\r\n            if (_allowStateReadsStart && _allowStateReadsEnd) {\r\n                prevReadState = _allowStateReadsStart(true)\r\n            }\r\n            getAtom.call(this).reportObserved()\r\n\r\n            if (_allowStateReadsStart && _allowStateReadsEnd) {\r\n                _allowStateReadsEnd(prevReadState)\r\n            }\r\n\r\n            return this[valueHolderKey]\r\n        },\r\n        set: function set(v) {\r\n            if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {\r\n                setHiddenProp(this, valueHolderKey, v)\r\n                setHiddenProp(this, skipRenderKey, true)\r\n                getAtom.call(this).reportChanged()\r\n                setHiddenProp(this, skipRenderKey, false)\r\n            } else {\r\n                setHiddenProp(this, valueHolderKey, v)\r\n            }\r\n        }\r\n    })\r\n}\r\n","import { shallowEqual } from \"./utils/utils\"\r\nimport { IValueMap } from \"./types/IValueMap\"\r\n\r\nexport const MobXProviderContext = React.createContext<IValueMap>({})\r\n\r\nexport interface ProviderProps extends IValueMap {\r\n    children: React.ReactNode\r\n}\r\n\r\nexport function Provider(props: ProviderProps) {\r\n    const { children, ...stores } = props\r\n    const parentValue = React.useContext(MobXProviderContext)\r\n    const mutableProviderRef = React.useRef({ ...parentValue, ...stores })\r\n    const value = mutableProviderRef.current\r\n\r\n    if (__DEV__) {\r\n        const newValue = { ...value, ...stores } // spread in previous state for the context based stores\r\n        if (!shallowEqual(value, newValue)) {\r\n            throw new Error(\r\n                \"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\"\r\n            )\r\n        }\r\n    }\r\n\r\n    return <MobXProviderContext.Provider value={value}>{children}</MobXProviderContext.Provider>\r\n}\r\n\r\nProvider.displayName = \"MobXProvider\"\r\n","import React from \"react\"\r\nimport { patch, newSymbol } from \"./utils/utils\"\r\n\r\ntype Disposer = () => void\r\n\r\nconst protoStoreKey = newSymbol(\"disposeOnUnmountProto\")\r\nconst instStoreKey = newSymbol(\"disposeOnUnmountInst\")\r\n\r\nfunction runDisposersOnWillUnmount() {\r\n    ;[...(this[protoStoreKey] || []), ...(this[instStoreKey] || [])].forEach(propKeyOrFunction => {\r\n        const prop =\r\n            typeof propKeyOrFunction === \"string\" ? this[propKeyOrFunction] : propKeyOrFunction\r\n        if (prop !== undefined && prop !== null) {\r\n            if (Array.isArray(prop)) prop.map(f => f())\r\n            else prop()\r\n        }\r\n    })\r\n}\r\n\r\nexport function disposeOnUnmount(target: React.Component<any, any>, propertyKey: PropertyKey): void\r\nexport function disposeOnUnmount<TF extends Disposer | Array<Disposer>>(\r\n    target: React.Component<any, any>,\r\n    fn: TF\r\n): TF\r\n\r\nexport function disposeOnUnmount(\r\n    target: React.Component<any, any>,\r\n    propertyKeyOrFunction: PropertyKey | Disposer | Array<Disposer>\r\n): PropertyKey | Disposer | Array<Disposer> | void {\r\n    if (Array.isArray(propertyKeyOrFunction)) {\r\n        return propertyKeyOrFunction.map(fn => disposeOnUnmount(target, fn))\r\n    }\r\n\r\n    const c = Object.getPrototypeOf(target).constructor\r\n    const c2 = Object.getPrototypeOf(target.constructor)\r\n    // Special case for react-hot-loader\r\n    const c3 = Object.getPrototypeOf(Object.getPrototypeOf(target))\r\n    if (\r\n        !(\r\n            c === React.Component ||\r\n            c === React.PureComponent ||\r\n            c2 === React.Component ||\r\n            c2 === React.PureComponent ||\r\n            c3 === React.Component ||\r\n            c3 === React.PureComponent\r\n        )\r\n    ) {\r\n        throw new Error(\r\n            \"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\"\r\n        )\r\n    }\r\n\r\n    if (\r\n        typeof propertyKeyOrFunction !== \"string\" &&\r\n        typeof propertyKeyOrFunction !== \"function\" &&\r\n        !Array.isArray(propertyKeyOrFunction)\r\n    ) {\r\n        throw new Error(\r\n            \"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\"\r\n        )\r\n    }\r\n\r\n    // decorator's target is the prototype, so it doesn't have any instance properties like props\r\n    const isDecorator = typeof propertyKeyOrFunction === \"string\"\r\n\r\n    // add property key / function we want run (disposed) to the store\r\n    const componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey]\r\n    const store = isDecorator\r\n        ? // decorators are added to the prototype store\r\n          target[protoStoreKey] || (target[protoStoreKey] = [])\r\n        : // functions are added to the instance store\r\n          target[instStoreKey] || (target[instStoreKey] = [])\r\n\r\n    store.push(propertyKeyOrFunction)\r\n\r\n    // tweak the component class componentWillUnmount if not done already\r\n    if (!componentWasAlreadyModified) {\r\n        patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount)\r\n    }\r\n\r\n    // return the disposer as is if invoked as a non decorator\r\n    if (typeof propertyKeyOrFunction !== \"string\") {\r\n        return propertyKeyOrFunction\r\n    }\r\n}\r\n","import { isObservableArray, isObservableObject, isObservableMap, untracked } from \"mobx\"\r\n\r\n// Copied from React.PropTypes\r\nfunction createChainableTypeChecker(validator: React.Validator<any>): React.Requireable<any> {\r\n    function checkType(\r\n        isRequired: boolean,\r\n        props: any,\r\n        propName: string,\r\n        componentName: string,\r\n        location: string,\r\n        propFullName: string,\r\n        ...rest: any[]\r\n    ) {\r\n        return untracked(() => {\r\n            componentName = componentName || \"<<anonymous>>\"\r\n            propFullName = propFullName || propName\r\n            if (props[propName] == null) {\r\n                if (isRequired) {\r\n                    const actual = props[propName] === null ? \"null\" : \"undefined\"\r\n                    return new Error(\r\n                        \"The \" +\r\n                            location +\r\n                            \" `\" +\r\n                            propFullName +\r\n                            \"` is marked as required \" +\r\n                            \"in `\" +\r\n                            componentName +\r\n                            \"`, but its value is `\" +\r\n                            actual +\r\n                            \"`.\"\r\n                    )\r\n                }\r\n                return null\r\n            } else {\r\n                // @ts-ignore rest arg is necessary for some React internals - fails tests otherwise\r\n                return validator(props, propName, componentName, location, propFullName, ...rest)\r\n            }\r\n        })\r\n    }\r\n\r\n    const chainedCheckType: any = checkType.bind(null, false)\r\n    // Add isRequired to satisfy Requirable\r\n    chainedCheckType.isRequired = checkType.bind(null, true)\r\n    return chainedCheckType\r\n}\r\n\r\n// Copied from React.PropTypes\r\nfunction isSymbol(propType: any, propValue: any): boolean {\r\n    // Native Symbol.\r\n    if (propType === \"symbol\") {\r\n        return true\r\n    }\r\n\r\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\r\n    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\r\n        return true\r\n    }\r\n\r\n    // Fallback for non-spec compliant Symbols which are polyfilled.\r\n    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\r\n        return true\r\n    }\r\n\r\n    return false\r\n}\r\n\r\n// Copied from React.PropTypes\r\nfunction getPropType(propValue: any): string {\r\n    const propType = typeof propValue\r\n    if (Array.isArray(propValue)) {\r\n        return \"array\"\r\n    }\r\n    if (propValue instanceof RegExp) {\r\n        // Old webkits (at least until Android 4.0) return 'function' rather than\r\n        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\r\n        // passes PropTypes.object.\r\n        return \"object\"\r\n    }\r\n    if (isSymbol(propType, propValue)) {\r\n        return \"symbol\"\r\n    }\r\n    return propType\r\n}\r\n\r\n// This handles more types than `getPropType`. Only used for error messages.\r\n// Copied from React.PropTypes\r\nfunction getPreciseType(propValue: any): string {\r\n    const propType = getPropType(propValue)\r\n    if (propType === \"object\") {\r\n        if (propValue instanceof Date) {\r\n            return \"date\"\r\n        } else if (propValue instanceof RegExp) {\r\n            return \"regexp\"\r\n        }\r\n    }\r\n    return propType\r\n}\r\n\r\nfunction createObservableTypeCheckerCreator(\r\n    allowNativeType: any,\r\n    mobxType: any\r\n): React.Requireable<any> {\r\n    return createChainableTypeChecker((props, propName, componentName, location, propFullName) => {\r\n        return untracked(() => {\r\n            if (allowNativeType) {\r\n                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null\r\n            }\r\n            let mobxChecker\r\n            switch (mobxType) {\r\n                case \"Array\":\r\n                    mobxChecker = isObservableArray\r\n                    break\r\n                case \"Object\":\r\n                    mobxChecker = isObservableObject\r\n                    break\r\n                case \"Map\":\r\n                    mobxChecker = isObservableMap\r\n                    break\r\n                default:\r\n                    throw new Error(`Unexpected mobxType: ${mobxType}`)\r\n            }\r\n            const propValue = props[propName]\r\n            if (!mobxChecker(propValue)) {\r\n                const preciseType = getPreciseType(propValue)\r\n                const nativeTypeExpectationMessage = allowNativeType\r\n                    ? \" or javascript `\" + mobxType.toLowerCase() + \"`\"\r\n                    : \"\"\r\n                return new Error(\r\n                    \"Invalid prop `\" +\r\n                        propFullName +\r\n                        \"` of type `\" +\r\n                        preciseType +\r\n                        \"` supplied to\" +\r\n                        \" `\" +\r\n                        componentName +\r\n                        \"`, expected `mobx.Observable\" +\r\n                        mobxType +\r\n                        \"`\" +\r\n                        nativeTypeExpectationMessage +\r\n                        \".\"\r\n                )\r\n            }\r\n            return null\r\n        })\r\n    })\r\n}\r\n\r\nfunction createObservableArrayOfTypeChecker(\r\n    allowNativeType: boolean,\r\n    typeChecker: React.Validator<any>\r\n) {\r\n    return createChainableTypeChecker(\r\n        (props, propName, componentName, location, propFullName, ...rest) => {\r\n            return untracked(() => {\r\n                if (typeof typeChecker !== \"function\") {\r\n                    return new Error(\r\n                        \"Property `\" +\r\n                            propFullName +\r\n                            \"` of component `\" +\r\n                            componentName +\r\n                            \"` has \" +\r\n                            \"invalid PropType notation.\"\r\n                    )\r\n                } else {\r\n                    let error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(\r\n                        props,\r\n                        propName,\r\n                        componentName,\r\n                        location,\r\n                        propFullName\r\n                    )\r\n\r\n                    if (error instanceof Error) return error\r\n                    const propValue = props[propName]\r\n                    for (let i = 0; i < propValue.length; i++) {\r\n                        error = (typeChecker as React.Validator<any>)(\r\n                            propValue,\r\n                            i as any,\r\n                            componentName,\r\n                            location,\r\n                            propFullName + \"[\" + i + \"]\",\r\n                            ...rest\r\n                        )\r\n                        if (error instanceof Error) return error\r\n                    }\r\n\r\n                    return null\r\n                }\r\n            })\r\n        }\r\n    )\r\n}\r\n\r\nconst observableArray = createObservableTypeCheckerCreator(false, \"Array\")\r\nconst observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false)\r\nconst observableMap = createObservableTypeCheckerCreator(false, \"Map\")\r\nconst observableObject = createObservableTypeCheckerCreator(false, \"Object\")\r\nconst arrayOrObservableArray = createObservableTypeCheckerCreator(true, \"Array\")\r\nconst arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true)\r\nconst objectOrObservableObject = createObservableTypeCheckerCreator(true, \"Object\")\r\n\r\nexport const PropTypes = {\r\n    observableArray,\r\n    observableArrayOf,\r\n    observableMap,\r\n    observableObject,\r\n    arrayOrObservableArray,\r\n    arrayOrObservableArrayOf,\r\n    objectOrObservableObject\r\n}\r\n","import { observable } from \"mobx\";\r\nimport { Component } from \"react\";\r\n\r\nif ( !Component ) throw new Error( \"mobx-react requires React to be available\" );\r\nif ( !observable ) throw new Error( \"mobx-react requires mobx to be available\" );\r\n\r\nexport {\r\n\tObserver ,\r\n\tuseObserver ,\r\n\tuseAsObservableSource ,\r\n\tuseLocalStore ,\r\n\tisUsingStaticRendering ,\r\n\tuseStaticRendering ,\r\n\tenableStaticRendering ,\r\n\tobserverBatching ,\r\n\tuseLocalObservable,\r\n} from \"reaxes-react/libs/mobx-react-lite\";\r\n\r\nexport { observer } from \"./observer\";\r\n\r\nexport {\r\n\tMobXProviderContext ,\r\n\tProvider ,\r\n} from \"./Provider\";\r\nexport { inject } from \"./inject\";\r\nexport { disposeOnUnmount } from \"./disposeOnUnmount\";\r\nexport { PropTypes } from \"./propTypes\";\r\nexport type { IWrappedComponent } from \"./types/IWrappedComponent\";\r\nexport type { ProviderProps } from './Provider';\r\n","import { Component } from 'react';\r\nimport { observer as observerLite , parentObserver} from 'reaxes-react/libs/mobx-react-lite';\r\nimport { observer } from 'reaxes-react/libs/mobx-react';\r\n\r\ntype Props = {\r\n\tinstance: React.Component;\r\n};\r\n\r\n/**\r\n * 包裹原始component , 集成了 mobx-react.observer , withHooks\r\n * @param OriginalComponent\r\n */\r\nexport function withHoC<T extends ( React.Component & React.FC )>( OriginalComponent: T ) {\r\n\t\r\n\t\r\n\t/*this is a FC*/\r\n\tif ( !OriginalComponent.prototype?.render ) {\r\n\t\treturn observerLite(OriginalComponent);\r\n\t}\r\n\t/**\r\n\t * 如果已经被Observer包裹过,则直接返回\r\n\t */\r\n\tif(Object.getOwnPropertySymbols(OriginalComponent).find((symbol) => symbol.description === \"isMobXReactObserver\" )){\r\n\t\treturn OriginalComponent;\r\n\t}\r\n\t\r\n\tconst baseRender = OriginalComponent.prototype.render;\r\n\t\r\n\tfunction HooksProvider( { instance } , ref ,  ): any {\r\n\t\t\r\n\t\r\n\t\treturn baseRender.call(instance);\r\n\t}\r\n\t\r\n\t// @ts-ignore  \r\n\tconst componentName = OriginalComponent.displayName || OriginalComponent.name || 'Component';\r\n\tHooksProvider.displayName = componentName + 'Hooks';\r\n\tconst H = parentObserver( HooksProvider );\r\n\t\r\n\t\r\n\tOriginalComponent.prototype.render = function (){\r\n\t\t// return React.createElement()\r\n\t\treturn <H instance={this} /*random = {Math.random()}*//>\r\n\t};\r\n\t\r\n\t\r\n\treturn observer(OriginalComponent);\r\n}\r\n\r\n\r\n","import * as React from 'react';\r\nimport { observer as observerLite } from 'reaxes-react/libs/mobx-react-lite';\r\n\r\nimport { makeClassComponentObserver } from './observerClass';\r\nimport { IReactComponent } from './types/IReactComponent';\r\n\r\n/**\r\n * Observer function / decorator\r\n */\r\nexport function observer<T extends IReactComponent>(component: T): T {\r\n\tif (component['isMobxInjector'] === true) {\r\n\t\tconsole.warn('Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`');\r\n\t}\r\n\t\r\n\treturn makeClassComponentObserver(component as React.ComponentClass<any, any>) as T;\r\n}\r\n","export { withHoC } from './withHoC';\r\n\r\nexport const compose = <T extends Function[]>( wrappers ) => {\r\n\t\r\n\tif ( wrappers.length === 0 ) {\r\n\t\t( arg ) => arg;\r\n\t}\r\n\t\r\n\tif ( wrappers.length === 1 ) {\r\n\t\treturn wrappers[ 0 ];\r\n\t}\r\n\t\r\n\treturn wrappers.reduce( ( accu , wrapper ) => ( ...args ) => accu( wrapper( ...args ) ) );\r\n};\r\n\r\n","import {\r\n\tcompose ,\r\n\twithHoC ,\r\n} from './enhancer';\r\nimport {observer} from 'reaxes-react/libs/mobx-react';\r\nconst componentHasWrapped = Symbol( '' );\r\n\r\nexport const reaxper = <T extends {}>(component : T) : T => {\r\n\t\r\n\tif(component.hasOwnProperty(componentHasWrapped)){\r\n\t\treturn component;\r\n\t}\r\n\t\r\n\tconst wrappedComponent = compose( [\r\n\t\twithHoC ,\r\n\t] )(component);\r\n\t\r\n\t/*flag to prevent duplicated wrap*/\r\n\twrappedComponent[componentHasWrapped] = true;\r\n\treturn wrappedComponent;\r\n};\r\n","import { Component } from 'react';\r\n\r\n\r\nexport class Reaxlass<Tprops extends {} = any , Tstate extends {} = any> extends Component<Tprops , Tstate> {\r\n\t\r\n\tJSX : { [ p : string ] : () => React.ReactElement | void | React.ReactNode };\r\n\t\r\n\tactions : { [ p : string ] : Function };\r\n\t\r\n\tmountedStack:{callback():any,id:string}[] = [];\r\n\t\r\n\tunmountStack:{callback():any,id:string}[] = [];\r\n\t\r\n\tupdatedStack:{callback():any,id:string}[] = [];\r\n\t\r\n\trenderedStack:{callback():any,id:string}[] = [];\r\n\t\r\n\t/**\r\n\t * didMount和didUpdate都要执行的函数,何不放在这里?\r\n\t */\r\n\tcomponentDidRender?( stage : \"mount\" | \"update\" , prevProps? : Readonly<Tprops> , prevState? : Readonly<Tstate> , snapshot? : any ) : any;\r\n\t\r\n};\r\n","var x = y => { var x = {}; __webpack_require__.d(x, y); return x; }\nvar y = x => () => x\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"Reaxes\"]: () => __WEBPACK_EXTERNAL_MODULE_reaxes__.Reaxes, [\"createReaxable\"]: () => __WEBPACK_EXTERNAL_MODULE_reaxes__.createReaxable, [\"reaxel\"]: () => __WEBPACK_EXTERNAL_MODULE_reaxes__.reaxel });"],"names":["module","exports","__WEBPACK_EXTERNAL_MODULE_react__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","y","x","__WEBPACK_EXTERNAL_MODULE_mobx__","$mobx","Reaction","_allowStateChanges","_allowStateReadsEnd","_allowStateReadsStart","configure","createAtom","getDependencyTree","isObservableArray","isObservableMap","isObservableObject","makeObservable","observable","untracked","useState","Error","__WEBPACK_EXTERNAL_MODULE_react_dom_7dac9eee__","unstable_batchedUpdates","defaultNoopBatch","callback","printDebugValue","v","FinalizationRegistryLocal","FinalizationRegistry","createTrackingData","reaction","mounted","changedBeforeMount","cleanAt","Date","now","CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS","_ref","FinalizationRegistryMaybeUndefined","cleanupTokenToReactionTrackingMap","Map","globalCleanupTokensCounter","registry","token","trackedReaction","dispose","addReactionToTrack","reactionTrackingRef","objectRetainedByReact","register","current","finalizationRegistryCleanupToken","set","recordReactionAsCommitted","reactionRef","unregister","forceCleanupTimerToRunNowForTests","resetCleanupScheduleForTests","createReactionCleanupTrackingUsingFinalizationRegister","reactionCleanupHandle","uncommittedReactionRefs","Set","ensureCleanupTimerRunning","setTimeout","cleanUncommittedReactions","forEach","ref","tracking","size","add","clearTimeout","_step","_iterator","_createForOfIteratorHelper","s","n","done","value","err","e","f","clear","createTimerBasedReactionCleanupTracking","globalIsUsingStaticRendering","isUsingStaticRendering","observerComponentNameFor","baseComponentName","concat","ObjectToBeRetainedByReact","_createClass","_classCallCheck","objectToBeRetainedByReactFactory","useObserver","fn","arguments","length","_slicedToArray","React","setState","forceUpdate","useRef","newReaction","trackingData","rendering","exception","useDebugValue","useEffect","Infinity","track","hasSymbol","Symbol","ReactForwardRefSymbol","forwardRef","props","ReactMemoSymbol","memo","observer","baseComponent","options","_options$forwardRef","useForwardRef","render","displayName","name","base","target","observerComponent","contextTypes","keys","hoistBlackList","getOwnPropertyDescriptor","$$typeof","compare","type","instance","parentForceUpdate","parentObserver","reactionScheduler","batch","symbolId","createdSymbols","newSymbol","symbol","createSymbol","shallowEqual","objA","objB","is","_typeof","keysA","keysB","i","setHiddenProp","configurable","writable","mobxMixins","mobxPatchedDefinition","wrapper","realMethod","mixins","_this","_len","args","Array","_key","locks","retVal","apply","this","methods","mx","wrapFunction","_len2","_key2","patch","methodName","mixinMethod","methodMixins","getMixins","indexOf","push","oldDefinition","originalMethod","newDefinition","createDefinition","wrappedFunc","_defineProperty","mobxAdminProperty","mobxObserverProperty","mobxIsUnmounted","skipRenderKey","isForcingUpdateKey","makeClassComponentObserver","componentClass","getDisplayName","console","warn","componentWillReact","PureComponent","shouldComponentUpdate","observerSCU","makeObservableProp","contextType","baseRender","makeComponentReactive","_this$render$mobxAdmi","comp","constructor","initialName","bind","isRenderingPending","hasError","Component","reactiveRender","nextProps","nextState","state","propName","valueHolderKey","atomHolderKey","getAtom","prevReadState","reportObserved","reportChanged","createContext","createChainableTypeChecker","validator","checkType","isRequired","componentName","location","propFullName","rest","actual","chainedCheckType","getPropType","propValue","propType","isArray","RegExp","isSymbol","createObservableTypeCheckerCreator","allowNativeType","mobxType","toLowerCase","mobxChecker","preciseType","getPreciseType","nativeTypeExpectationMessage","createObservableArrayOfTypeChecker","typeChecker","error","withHoC","OriginalComponent","_OriginalComponent$pr","observerLite","getOwnPropertySymbols","find","description","HooksProvider","component","H","createElement","componentHasWrapped","reaxper","wrappers","wrappedComponent","reduce","accu","Reaxlass","_Component","_inherits","_super","_createSuper","_assertThisInitialized","__WEBPACK_EXTERNAL_MODULE_reaxes__","Reaxes","createReaxable","reaxel"],"sourceRoot":""}